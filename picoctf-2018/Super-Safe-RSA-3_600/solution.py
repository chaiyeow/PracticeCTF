c = 13019378339024937880656070435339259722005068001063934168043323620450684522135783470962275586662335011496155846891455669545563072716823750676999505079305263324222268771591506086966696957024571269607853392089290610516177198603068201096077355126355600343308009224640828610230616991202788382469611117708753997
n = 16870433965497882404186802195664091273360001985391125376811000134053895079312416458105359833688792708460133924780293491549600851896180645550179479493657401252725366565332299520764215870953614391743650529461145751823298247142299891711255130103349519226864813532191832738137181154269562445602601817997360659
e = 65537

def egcd(a,b): # Extended Euclidean Algorithm
    if a == 0:
        return (b,0,1);
    else:
        g,y,x = egcd(b%a,a);
        return (g, x - (b // a) * y, y);

def modinv(a,m): # Modular Inverse Finder
    g, x, y = egcd(a,m);
    if g != 1:
        raise Exception('modular inverse does not exist');
    else:
        return x % m;

# Calculate the totient given the factors
tot=16870433794385310949797518814764654180130426706088295911334826362427488877571507560127899589074336317726423606663033947673780168027474858487529890958946698798641566470473124399855843846085619840664251799995192797240580970275613784923014875731200438913200506918161928980261422217477625229443085841203200000
d = modinv(e, tot)

m = pow(c, d, n)
print(("%x" % m).decode("hex"))

"""
The Ns generated by the server have multiple primes, which we can easily factor and calculate the totient.
With the totient, we can calculate the correct d to decrypt the ciphertext.

picoCTF{p_&_q_n0_r_$_t!!_5146060}
"""
